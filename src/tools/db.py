"""Database adapter utilities, including PostGIS interaction."""

import os
import re  # For regex-based allowlist
import psycopg
from psycopg.rows import dict_row
from typing import List, Dict, Any, Optional
import datetime
import decimal

# Helper function to make data JSON serializable
def make_serializable(data: Any) -> Any:
    if isinstance(data, list):
        return [make_serializable(item) for item in data]
    elif isinstance(data, dict):
        return {key: make_serializable(value) for key, value in data.items()}
    elif isinstance(data, datetime.datetime):
        return data.isoformat()
    elif isinstance(data, datetime.date):
        return data.isoformat()
    elif isinstance(data, decimal.Decimal):
        return str(data)  # Convert Decimal to string to preserve precision
    return data

# TODO: Securely manage connection parameters (e.g., via environment variables)
DB_NAME = os.getenv("POSTGRES_DB", "spatial_ai_db")
DB_USER = os.getenv("POSTGRES_USER", "postgres")  # Updated default user
DB_PASSWORD = os.getenv("POSTGRES_PASSWORD", "password")
DB_HOST = os.getenv("POSTGRES_HOST", "localhost")
DB_PORT = os.getenv("POSTGRES_PORT", "5432")

# SQL Allowlist Patterns (for queries generated by the agent)
# As per .cursorrules: readonly for all automated SQL execution
AGENT_SQL_ALLOWLIST_PATTERNS = [
    re.compile(r"^SELECT", re.IGNORECASE),
    re.compile(r"^WITH", re.IGNORECASE),
    # Add ST_ function calls; be mindful of how this is checked (e.g., presence of "ST_")
    # A simple check for "ST_" might be too broad or too narrow depending on context.
    # For now, we assume a query containing ST_ functions will start with SELECT or WITH.
]
# A more specific check for ST_ might involve ensuring it's part of a SELECT/WITH query.
# For example, one could check: `pattern.match(sql_query) and "ST_" in sql_query.upper()`
# However, this is a basic implementation.


# As per .cursorrules, all SQL should be executed via this function.
# It should enforce the readonly role and SQL allowlist patterns for agent-generated queries.
def execute_sql_on_postgis(
    sql_query: str, params: Optional[Dict[str, Any]] = None, is_agent_query: bool = True
) -> Optional[List[Dict[str, Any]]]:
    """
    Executes a SQL query on the PostGIS database.

    Args:
        sql_query: The SQL query string.
        params: Optional dictionary of parameters to pass to the query.
        is_agent_query: If True (default), applies strict agent SQL allowlist.
                        If False, assumes internal system query (e.g., logging)
                        and bypasses strict allowlist for designated operations.

    Returns:
        A list of dictionaries representing the query results, or None if an error occurs.
        For non-SELECT queries that succeed (like INSERT with RETURNING),
        it returns the result of RETURNING. For DML without RETURNING, it returns [].

    Raises:
        ValueError: If an agent-generated SQL query does not conform to allowlist patterns.
    """

    # Allowlist check for agent-generated queries
    if is_agent_query:
        is_allowed = any(
            pattern.match(sql_query) for pattern in AGENT_SQL_ALLOWLIST_PATTERNS
        )
        # Further check for ST_ functions if necessary, e.g., ensure "ST_" is present if it's a spatial query.
        # This part can be refined. For now, starting with SELECT/WITH is the main check.
        if not is_allowed:
            # A simple check for presence of ST_ functions for spatial queries if not covered by SELECT/WITH
            # This is a basic check and might need refinement for robustness.
            if "ST_" not in sql_query.upper():
                raise ValueError(
                    f"Agent query does not conform to SQL allowlist (must be SELECT, WITH, or contain ST_ functions). Query: {sql_query[:200]}..."
                )
            # If ST_ is present, we assume it's a valid spatial query (this logic can be tightened)

    # TODO: Enforce readonly database role for all automated SQL execution for agent queries.
    # This might involve setting session characteristics or using a specific readonly user.
    # For now, we connect with the provided user. The allowlist is the primary gate.

    conn_string = f"dbname={DB_NAME} user={DB_USER} password={DB_PASSWORD} host={DB_HOST} port={DB_PORT}"

    # ---- START DEBUGGING ----
    # print(f"---- DEBUG: Current conn_string: '{conn_string}' ----")
    # print(f"---- DEBUG: os.environ.get('LANGUAGE'): '{os.environ.get('LANGUAGE')}' ----")
    # print(f"---- DEBUG: os.environ.get('LANG'): '{os.environ.get('LANG')}' ----")
    # print(f"---- DEBUG: os.environ.get('PGOPTIONS'): '{os.environ.get('PGOPTIONS')}' ----")
    # ---- END DEBUGGING ----

    try:
        with psycopg.connect(conn_string, row_factory=dict_row) as conn:
            with conn.cursor() as cur:
                # For internal system queries (like INSERT to log table), don't use readonly transaction.
                # For agent queries, enforce readonly if possible at connection/transaction level.
                # For now, allowlist is the main control for agent queries.
                # if is_agent_query:
                #     conn.readonly = True # Example, actual implementation might vary

                cur.execute(sql_query, params)

                if (
                    cur.description
                ):  # Indicates a query that can return rows (SELECT, or DML with RETURNING)
                    results = cur.fetchall()
                    return results  # Will be an empty list if RETURNING clause didn't match or SELECT had no rows
                else:
                    # For DML without RETURNING (e.g., simple INSERT, UPDATE, DELETE)
                    # These should generally be disallowed for agent queries by the allowlist.
                    # If it's a system query (is_agent_query=False), commit is needed.
                    if not is_agent_query:  # Commit only for system DML
                        conn.commit()
                    return []  # Indicate success for non-returning DML

    except psycopg.Error as e:
        # TODO: Implement proper logging (using a logging library)
        print(f"Database error: {e} for query: {sql_query[:200]}...")
        return None
    except ValueError as ve:
        # Re-raise ValueErrors from allowlist checks
        print(f"ValueError: {ve}")  # Logging it here as well
        raise ve


def log_nlq_interaction(
    natural_language_query: str,
    generated_sql_query: Optional[str] = None,
    sql_execution_raw_result: Optional[
        Dict[str, Any]
    ] = None,  # Assuming JSONB will be passed as dict
    processed_analysis_result: Optional[str] = None,
    session_id: Optional[str] = None,
    agent_version: Optional[str] = None,
    llm_model_used: Optional[str] = None,
    latency_ms: Optional[int] = None,
    prompt_tokens: Optional[int] = None,
    completion_tokens: Optional[int] = None,
    total_tokens: Optional[int] = None,
    cost_usd_cents: Optional[float] = None,  # Using float for decimal
    human_feedback_score: Optional[int] = None,
    human_feedback_notes: Optional[str] = None,
    is_correct: Optional[bool] = None,
    expected_sql_query: Optional[str] = None,
    expected_result: Optional[
        Dict[str, Any]
    ] = None,  # Assuming JSONB will be passed as dict
) -> Optional[int]:
    """
    Logs an interaction with the NLQ agent to the nlq_agent_log table.

    Args:
        All arguments correspond to the columns in the nlq_agent_log table.
        JSONB fields (sql_execution_raw_result, expected_result) are expected as Python dicts.

    Returns:
        The log_id of the newly inserted record, or None if an error occurred.
    """
    # Serialize data before passing to Jsonb
    serializable_sql_execution_raw_result = make_serializable(sql_execution_raw_result)
    serializable_expected_result = make_serializable(expected_result)

    insert_query = """
        INSERT INTO nlq_agent_log (
            natural_language_query, session_id, generated_sql_query, 
            sql_execution_raw_result, processed_analysis_result, agent_version, 
            llm_model_used, latency_ms, prompt_tokens, completion_tokens, 
            total_tokens, cost_usd_cents, human_feedback_score, 
            human_feedback_notes, is_correct, expected_sql_query, expected_result
        ) VALUES (
            %(natural_language_query)s, %(session_id)s, %(generated_sql_query)s,
            %(sql_execution_raw_result)s, %(processed_analysis_result)s, %(agent_version)s,
            %(llm_model_used)s, %(latency_ms)s, %(prompt_tokens)s, %(completion_tokens)s,
            %(total_tokens)s, %(cost_usd_cents)s, %(human_feedback_score)s,
            %(human_feedback_notes)s, %(is_correct)s, %(expected_sql_query)s, %(expected_result)s
        ) RETURNING log_id;
    """

    params = {
        "natural_language_query": natural_language_query,
        "session_id": session_id,
        "generated_sql_query": generated_sql_query,
        "sql_execution_raw_result": (
            psycopg.types.json.Jsonb(serializable_sql_execution_raw_result)
            if serializable_sql_execution_raw_result is not None
            else None
        ),
        "processed_analysis_result": processed_analysis_result,
        "agent_version": agent_version,
        "llm_model_used": llm_model_used,
        "latency_ms": latency_ms,
        "prompt_tokens": prompt_tokens,
        "completion_tokens": completion_tokens,
        "total_tokens": total_tokens,
        "cost_usd_cents": cost_usd_cents,
        "human_feedback_score": human_feedback_score,
        "human_feedback_notes": human_feedback_notes,
        "is_correct": is_correct,
        "expected_sql_query": expected_sql_query,
        "expected_result": (
            psycopg.types.json.Jsonb(serializable_expected_result)
            if serializable_expected_result is not None
            else None
        ),
    }

    try:
        # This is an internal system query, so is_agent_query=False
        result = execute_sql_on_postgis(insert_query, params, is_agent_query=False)
        if result and len(result) > 0 and "log_id" in result[0]:
            return result[0]["log_id"]
        elif (
            result == []
        ):  # Successful DML without returning, though we expect RETURNING here
            print("Warning: Log insertion succeeded but did not return log_id.")
            return None
        else:
            print("Error: Log insertion failed or did not return log_id.")
            return None
    except Exception as e:  # Catch any exception during the process
        print(f"Error during log insertion: {e}")
        return None


if __name__ == "__main__":
    # Example Usage (requires a running PostGIS instance and configured DB/user)

    # Test 1: Basic SELECT (should be allowed as agent_query=True by default)
    print("Testing basic SELECT...")
    test_query_select = "SELECT version();"
    try:
        version_info = execute_sql_on_postgis(test_query_select)
        if version_info is not None and version_info:
            print(f"PostgreSQL Version: {version_info[0]['version']}")
        else:
            print("SELECT query failed or returned no result.")
    except ValueError as e:
        print(f"Error: {e}")
    print("---\n")

    # Test 2: SELECT with ST_ function (should be allowed)
    print("Testing SELECT with ST_ function...")
    # Ensure ST_ is part of the query string for the basic allowlist check to pass
    test_query_st = "SELECT ST_AsText(ST_MakePoint(1, 2)) as point_text;"
    try:
        point_result = execute_sql_on_postgis(test_query_st)
        if point_result is not None and point_result:
            print(f"ST_MakePoint Result: {point_result[0]['point_text']}")
        else:
            print("ST_ function query failed or returned no result.")
    except ValueError as e:
        print(f"Error: {e}")
    print("---\n")

    # Test 3: Log an agent interaction
    print("Testing logging an NLQ interaction...")
    log_id = log_nlq_interaction(
        natural_language_query="What is the tallest building in Paris?",
        generated_sql_query="SELECT name, height FROM buildings WHERE city = 'Paris' ORDER BY height DESC LIMIT 1;",
        sql_execution_raw_result={"name": "Eiffel Tower", "height": 330},
        processed_analysis_result="The Eiffel Tower is the tallest, at 330m.",
        agent_version="0.1.0",
        llm_model_used="gpt-4o-mini",
        latency_ms=1500,
        prompt_tokens=200,
        completion_tokens=50,
        total_tokens=250,
        cost_usd_cents=0.025,
    )
    if log_id is not None:
        print(f"Successfully logged interaction with log_id: {log_id}")
        # Verify by fetching the log
        verify_log = execute_sql_on_postgis(
            f"SELECT * FROM nlq_agent_log WHERE log_id = {log_id};",
            is_agent_query=False,
        )  # is_agent_query=False for system check
        if verify_log:
            print(f"Verified log entry: {verify_log[0]}")
        else:
            print("Could not verify log entry.")
    else:
        print("Failed to log interaction.")
    print("---\n")

    # Test 4: Agent query that should be disallowed (e.g., UPDATE)
    print("Testing disallowed agent query (UPDATE)...")
    test_query_update = (
        "UPDATE nlq_agent_log SET agent_version = '0.1.1' WHERE log_id = 1;"
    )
    try:
        execute_sql_on_postgis(test_query_update, is_agent_query=True)
        print("UPDATE query was unexpectedly allowed for agent.")
    except ValueError as e:
        print(f"Successfully blocked by SQL allowlist: {e}")
    print("---\n")

    # Test 5: Count records in test_viirs_fire_events
    print("Counting records in test_viirs_fire_events...")
    test_query_count_viirs = "SELECT COUNT(*) AS count FROM test_viirs_fire_events;"
    try:
        count_result_viirs = execute_sql_on_postgis(
            test_query_count_viirs, is_agent_query=False
        )  # System query
        if count_result_viirs is not None and count_result_viirs:
            print(f"test_viirs_fire_events count: {count_result_viirs[0]['count']}")
        else:
            print("VIIRS count query failed or returned no result.")
    except Exception as e:
        print(f"Error counting VIIRS records: {e}")
    print("---\n")

    # Test 6: Count records in test_acled_conflict_events
    print("Counting records in test_acled_conflict_events...")
    test_query_count_acled = "SELECT COUNT(*) AS count FROM test_acled_conflict_events;"
    try:
        count_result_acled = execute_sql_on_postgis(
            test_query_count_acled, is_agent_query=False
        )  # System query
        if count_result_acled is not None and count_result_acled:
            print(f"test_acled_conflict_events count: {count_result_acled[0]['count']}")
        else:
            print("ACLED count query failed or returned no result.")
    except Exception as e:
        print(f"Error counting ACLED records: {e}")
    print("---\n")
